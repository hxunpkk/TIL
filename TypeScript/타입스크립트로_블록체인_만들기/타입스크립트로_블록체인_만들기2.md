## Call Signatures

íƒ€ì… ìŠ¤í¬ë¦½íŠ¸ì—ì„œ functionì„ ë§Œë“¤ë•Œ, ë§¤ê°œë³€ìˆ˜ì˜ íƒ€ì…ì„ ì§€ì •í•´ ì£¼ì–´ì•¼ í•¨
```
function add(a:number, b:number) {
    return a + b
}
```

call signature ì„ ì–¸ì„ í†µí•´ ìœ„ ì½”ë“œë¥¼ ë¶„ë¦¬í•  ìˆ˜ ìˆìŒ
```
type Add = (a:number, b:number) => number;

const add:Add = (a, b) => a + b
const add:Add = (a, b) => { a+b } ğŸš«
// ì•„ë˜ ì½”ë“œëŠ” returnì´ numberê°€ ì•„ë‹Œ voidê°€ return ë˜ë¯€ë¡œ ì—ëŸ¬ê°€ ëœ¸!
```
ë¨¼ì € í•¨ìˆ˜ì˜ íƒ€ì…ì„ ì„¤ëª…í•˜ê³  ë‚˜ì„œ ì½”ë“œë¥¼ êµ¬í˜„í•˜ê²Œ ë˜ë¯€ë¡œ ê°œë°œìê°€ íƒ€ì…ì„ ìƒê°í•˜ë„ë¡ í•´ì¤Œ.

<br>

## Overloading

ëŒ€ë¶€ë¶„ ë‹¤ë¥¸ì‚¬ëŒë“¤ì´ ë§Œë“œëŠ” ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í• í…ë° ì´ ë•Œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë‚˜ íŒ¨í‚¤ì§€ë“¤ì€ ì˜¤ë²„ë¡œë”©ì„ ë§ì´ ì‚¬ìš©í•¨.

ì˜¤ë²„ë¡œë”©ì€ í•¨ìˆ˜ê°€ ì„œë¡œ ë‹¤ë¥¸ ì—¬ëŸ¬ ê°œì˜ call signaturesë¥¼ ê°€ì§€ê³  ìˆì„ë•Œ ë°œìƒì‹œí‚´

```
type Add = {
    (a: number, b: number) : number
    (a: number, b: string) : number
}

const add: Add = (a, b) => {
    if(typeof b === "string") return a
    return a + b
}
```

ë§¤ê°œë³€ìˆ˜ì˜ ê°¯ìˆ˜ê°€ ë‹¤ë¥¸ ê²½ìš°?
```
type Add = {
    (a: number, b:number): number
    (a: number, b:number, c:number): number
}

const add: Add = (a, b, c?:number) => {
    if(c) return a + b + c
    return a + b
}
```

ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì•„ë˜ì™€ ê°™ì€ ë°©ì‹ì„ ìì£¼ ë³¼ ìˆ˜ ìˆë‹¤.
```
Router.push({
    path: "/home",
    state: 1
})

.push("/home")
```

Next.js ë¼ìš°í„°ì˜ pushê°€ ë‘ê°€ì§€ ë°©ë²•ì„ í˜ì´ì§€ë¥¼ ì´ë™í•œë‹¤ê³  í•  ë•Œ<br>
ì•„ë˜ ì½”ë“œëŠ” íŒ¨í‚¤ì§€ë‚˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ìì£¼ ë””ìì¸ ë  ìˆ˜ ìˆëŠ” ì½”ë“œ ë°©ì‹ì´ë‹¤.
```
type Config = {
    path: string,
    state: object
}

type Push = {
    (path: string): void
    (config: Config): void
}

const push: Push = (config) => {
    if (typeof config === "string"){
        console.log(config);
    } else {
        console.log(config.path);
    }
}
```

<br>

## Polymorphism(ë‹¤í˜•ì„±)

```
poly? => several, many, much, multi (ë§ì€, ë‹¤ìˆ˜)
morphos? =? form(í˜•íƒœ), structure(êµ¬ì¡°)
Polymorhous? => poly + morphos (ì—¬ëŸ¬ê°€ì§€ ë‹¤ë¥¸ êµ¬ì¡°ë“¤)
```

â— concrete type?
+ number, boolean, string, void, unknown...

â— generic type?
+ íƒ€ì…ì˜ placeholder ê°™ì€ ê²ƒ
+ call signature ë¥¼ ì‘ì„±í•  ë•Œ ë“¤ì–´ê°ˆ í™•ì‹¤í•œ íƒ€ì…ì„ ëª¨ë¥¼ ë•Œ ì‚¬ìš©
+ ì œë„¤ë¦­ì€ ì„ ì–¸ ì‹œì ì´ ì•„ë‹ˆë¼ ìƒì„± ì‹œì ì— íƒ€ì…ì„ ëª…ì‹œí•˜ì—¬ í•˜ë‚˜ì˜ íƒ€ì…ë§Œì´ ì•„ë‹Œ ë‹¤ì–‘í•œ íƒ€ì…ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ê¸°ë²•.

generic ì˜ˆì‹œ ì½”ë“œ

```
type SuperPrint = {
    <TypePlaceholder>(arr: TypePlaceholder[]): void
}

type SuperReturn = {
    <TypePlaceholder>(arr: TypePlaceholder[]): TypePlaceholder
}

const superPrint: SuperPrint = (arr) => {
    arr.forEach(i => console.log(i))
}

const superReturn: SuperReturn = (arr) => arr[0]

superPrint([1, 2, true, false])
superPrint([1, 2, true, false, "hello"])
const d = superReturn([1, 2, true, false])
const e = superReturn([1, 2, true, false, "hello"])
```

ìœ„ ì½”ë“œëŠ” ì´ëŸ°ì‹ìœ¼ë¡œ ê°„ë‹¨í•˜ê²Œ ì‘ì„±í•  ìˆ˜ë„ ìˆë‹¤

```
type SuperPrint = {
    <T>(arr: T[]): void
}

type SuperReturn = {
    <T>(arr: T[]): <T>
}
```

â— any ì™€ generic ì˜ ì°¨ì´?

```
type SuperPrint = {
    (arr: any[]): any
}

const superPrint: SuperPrint = (arr) => arr[0]

let a = superPrint([1, "b", true]);
a.toUpperCase(); // any ì˜ ê²½ìš° í•´ë‹¹ ì½”ë“œ ì—ëŸ¬ ë°œìƒ X
```

```
type SuperPrint = {
    (arr: T[]): T
}

const superPrint: SuperPrint = (arr) => arr[0]

let a = superPrint([1, "b", true]);
a.toUpperCase(); // ì—ëŸ¬ ë°œìƒ!
```

Genericì˜ ê²½ìš° ì—ëŸ¬ê°€ ë°œìƒí•´ ë³´í˜¸ë°›ì„ ìˆ˜ ìˆë‹¤. <br>
Call Signatureë¥¼ concrete typeìœ¼ë¡œ í•˜ë‚˜ì”© ì¶”ê°€í•˜ëŠ” í˜•íƒœì´ê¸° ë•Œë¬¸!

â— ì•„ë˜ ì½”ë“œì²˜ëŸ¼ ë³µìˆ˜ë¡œ generic ì„ ì„ ì–¸í•  ìˆ˜ë„ ìˆë‹¤
```
type SuperPrint = {
    (arr: T[], x: M): T
}

const superPrint: SuperPrint = (arr, x) => arr[0]

let a = superPrint([1, "b", true], "hi");
```

<br>
<br>

# Refer
nomadcoders - íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ë¡œ ë¸”ë¡ì²´ì¸ ë§Œë“¤ê¸°