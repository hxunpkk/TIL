## Call Signatures

타입 스크립트에서 function을 만들때, 매개변수의 타입을 지정해 주어야 함
```
function add(a:number, b:number) {
    return a + b
}
```

call signature 선언을 통해 위 코드를 분리할 수 있음
```
type Add = (a:number, b:number) => number;

const add:Add = (a, b) => a + b
const add:Add = (a, b) => { a+b } 🚫
// 아래 코드는 return이 number가 아닌 void가 return 되므로 에러가 뜸!
```
먼저 함수의 타입을 설명하고 나서 코드를 구현하게 되므로 개발자가 타입을 생각하도록 해줌.

<br>

## Overloading

대부분 다른사람들이 만드는 외부 라이브러리를 사용할텐데 이 때 라이브러리나 패키지들은 오버로딩을 많이 사용함.

오버로딩은 함수가 서로 다른 여러 개의 call signatures를 가지고 있을때 발생시킴

```
type Add = {
    (a: number, b: number) : number
    (a: number, b: string) : number
}

const add: Add = (a, b) => {
    if(typeof b === "string") return a
    return a + b
}
```

매개변수의 갯수가 다른 경우?
```
type Add = {
    (a: number, b:number): number
    (a: number, b:number, c:number): number
}

const add: Add = (a, b, c?:number) => {
    if(c) return a + b + c
    return a + b
}
```

외부 라이브러리에서 아래와 같은 방식을 자주 볼 수 있다.
```
Router.push({
    path: "/home",
    state: 1
})

.push("/home")
```

Next.js 라우터의 push가 두가지 방법을 페이지를 이동한다고 할 때<br>
아래 코드는 패키지나 라이브러리에서 자주 디자인 될 수 있는 코드 방식이다.
```
type Config = {
    path: string,
    state: object
}

type Push = {
    (path: string): void
    (config: Config): void
}

const push: Push = (config) => {
    if (typeof config === "string"){
        console.log(config);
    } else {
        console.log(config.path);
    }
}
```
<br>
<br>

# Refer
nomadcoders - 타입스크립트로 블록체인 만들기